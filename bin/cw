#!/usr/bin/env bash
# cw - Claude Worktree Developer Tool
# A comprehensive CLI for git worktrees, Claude Code, GitHub, and terminal integration
#
# https://github.com/YOUR_USERNAME/cw

set -euo pipefail

VERSION="1.1.0"

# ─────────────────────────────────────────────────────────────────────────────
# Colors (with fallback for non-color terminals)
# ─────────────────────────────────────────────────────────────────────────────

if [[ -t 1 ]] && [[ "${TERM:-}" != "dumb" ]]; then
  RED='\033[0;31m'
  GREEN='\033[0;32m'
  YELLOW='\033[1;33m'
  BLUE='\033[0;34m'
  CYAN='\033[0;36m'
  MAGENTA='\033[0;35m'
  BOLD='\033[1m'
  DIM='\033[2m'
  NC='\033[0m'
else
  RED='' GREEN='' YELLOW='' BLUE='' CYAN='' MAGENTA='' BOLD='' DIM='' NC=''
fi

# ─────────────────────────────────────────────────────────────────────────────
# Platform Detection
# ─────────────────────────────────────────────────────────────────────────────

detect_os() {
  case "$(uname -s)" in
    Darwin*) echo "macos" ;;
    Linux*)  echo "linux" ;;
    MINGW*|MSYS*|CYGWIN*) echo "windows" ;;
    *)       echo "unknown" ;;
  esac
}

detect_terminal() {
  local os
  os=$(detect_os)

  if [[ "$os" == "macos" ]]; then
    if [[ -n "${WARP_SESSION_ID:-}" ]]; then
      echo "warp"
    elif [[ "${TERM_PROGRAM:-}" == "iTerm.app" ]]; then
      echo "iterm"
    elif [[ "${TERM_PROGRAM:-}" == "Apple_Terminal" ]]; then
      echo "terminal"
    else
      echo "generic"
    fi
  elif [[ "$os" == "linux" ]]; then
    if [[ -n "${KITTY_WINDOW_ID:-}" ]]; then
      echo "kitty"
    elif [[ -n "${GNOME_TERMINAL_SCREEN:-}" ]]; then
      echo "gnome-terminal"
    else
      echo "generic"
    fi
  else
    echo "generic"
  fi
}

OS=$(detect_os)
TERMINAL=$(detect_terminal)

# Cross-platform sed -i
sed_inplace() {
  if [[ "$OS" == "macos" ]]; then
    sed -i '' "$@"
  else
    sed -i "$@"
  fi
}

# ─────────────────────────────────────────────────────────────────────────────
# Core Utilities
# ─────────────────────────────────────────────────────────────────────────────

get_git_root() {
  git rev-parse --show-toplevel 2>/dev/null || {
    echo -e "${RED}Error: Not in a git repository${NC}" >&2
    exit 1
  }
}

get_current_branch() {
  git branch --show-current 2>/dev/null
}

get_repo_name() {
  basename "$(get_git_root)"
}

get_wt_base() {
  local root="$1"
  if [[ -f "$root/.worktreerc" ]]; then
    local custom_base
    custom_base=$(grep "^WT_BASE=" "$root/.worktreerc" 2>/dev/null | cut -d= -f2)
    if [[ -n "$custom_base" ]]; then
      echo "${custom_base/#\~/$HOME}"
      return
    fi
  fi
  echo "${root}__wt"
}

branch_to_dir() {
  echo "${1//\//-}"
}

get_port_config() {
  local root="$1"
  echo "${root}/.worktree-ports"
}

get_config_value() {
  local root="$1"
  local key="$2"
  local default="${3:-}"

  if [[ -f "$root/.worktreerc" ]]; then
    local value
    value=$(grep "^${key}=" "$root/.worktreerc" 2>/dev/null | cut -d= -f2)
    if [[ -n "$value" ]]; then
      echo "$value"
      return
    fi
  fi
  echo "$default"
}

# ─────────────────────────────────────────────────────────────────────────────
# Port Detection & Management
# ─────────────────────────────────────────────────────────────────────────────

detect_base_port() {
  local root="$1"

  local port
  port=$(get_config_value "$root" "BASE_PORT" "")
  if [[ -n "$port" ]]; then
    echo "$port"
    return
  fi

  if [[ -f "$root/package.json" ]]; then
    local detected=""
    detected=$(grep -E '"dev:next"|"dev"|"start"' "$root/package.json" 2>/dev/null | grep -oE '\-p[[:space:]]*[0-9]{4}' | head -1 | grep -oE '[0-9]{4}' || true)
    if [[ -n "$detected" ]]; then
      echo "$detected"
      return
    fi
    detected=$(grep -E '"dev:next"|"dev"|"start"' "$root/package.json" 2>/dev/null | grep -oE '\-\-port[[:space:]]*[0-9]{4}' | head -1 | grep -oE '[0-9]{4}' || true)
    if [[ -n "$detected" ]]; then
      echo "$detected"
      return
    fi
  fi

  for envfile in .env .env.local .env.development; do
    if [[ -f "$root/$envfile" ]]; then
      port=$(grep -E "^PORT=" "$root/$envfile" 2>/dev/null | cut -d= -f2 | tr -d '"'"'" || true)
      if [[ -n "$port" ]]; then
        echo "$port"
        return
      fi
    fi
  done

  echo "3000"
}

find_next_port() {
  local root="$1"
  local base_port="$2"
  local config
  config=$(get_port_config "$root")

  for ((port=base_port; port<base_port+20; port++)); do
    if ! grep -q "^[^:]*:$port$" "$config" 2>/dev/null; then
      echo "$port"
      return
    fi
  done

  echo -e "${RED}Error: No available ports${NC}" >&2
  exit 1
}

get_port_for_branch() {
  local root="$1"
  local branch="$2"
  local config
  config=$(get_port_config "$root")

  if [[ -f "$config" ]]; then
    grep "^${branch}:" "$config" 2>/dev/null | cut -d: -f2 || true
  fi
}

assign_port() {
  local root="$1"
  local branch="$2"
  local port="$3"
  local config
  config=$(get_port_config "$root")

  if [[ -f "$config" ]]; then
    grep -v "^${branch}:" "$config" > "${config}.tmp" 2>/dev/null || true
    mv "${config}.tmp" "$config"
  fi

  echo "${branch}:${port}" >> "$config"
}

remove_port() {
  local root="$1"
  local branch="$2"
  local config
  config=$(get_port_config "$root")

  if [[ -f "$config" ]]; then
    grep -v "^${branch}:" "$config" > "${config}.tmp" 2>/dev/null || true
    mv "${config}.tmp" "$config"
  fi
}

is_port_in_use() {
  local port="$1"
  if command -v lsof >/dev/null 2>&1; then
    lsof -i ":$port" >/dev/null 2>&1
  elif command -v ss >/dev/null 2>&1; then
    ss -tuln | grep -q ":$port "
  elif command -v netstat >/dev/null 2>&1; then
    netstat -tuln | grep -q ":$port "
  else
    return 1
  fi
}

# ─────────────────────────────────────────────────────────────────────────────
# Package Manager Detection
# ─────────────────────────────────────────────────────────────────────────────

detect_package_manager() {
  local dir="$1"
  if [[ -f "$dir/pnpm-lock.yaml" ]]; then
    echo "pnpm"
  elif [[ -f "$dir/bun.lockb" ]]; then
    echo "bun"
  elif [[ -f "$dir/yarn.lock" ]]; then
    echo "yarn"
  elif [[ -f "$dir/package-lock.json" ]]; then
    echo "npm"
  else
    echo "npm"
  fi
}

get_lock_file() {
  local pm="$1"
  case "$pm" in
    pnpm) echo "pnpm-lock.yaml" ;;
    bun)  echo "bun.lockb" ;;
    yarn) echo "yarn.lock" ;;
    npm)  echo "package-lock.json" ;;
  esac
}

get_install_cmd() {
  local pm="$1"
  case "$pm" in
    pnpm) echo "pnpm install --prefer-offline" ;;
    bun)  echo "bun install" ;;
    yarn) echo "yarn install --prefer-offline" ;;
    npm)  echo "npm ci" ;;
  esac
}

# ─────────────────────────────────────────────────────────────────────────────
# Environment & Symlink Setup
# ─────────────────────────────────────────────────────────────────────────────

detect_env_files() {
  local root="$1"
  local files
  files=$(get_config_value "$root" "ENV_FILES" "")
  if [[ -n "$files" ]]; then
    echo "$files"
    return
  fi

  local found=""
  for f in .env .env.local .env.development .env.development.local; do
    if [[ -f "$root/$f" ]]; then
      found="$found $f"
    fi
  done
  echo "$found"
}

detect_symlink_dirs() {
  local root="$1"
  local dirs
  dirs=$(get_config_value "$root" "SYMLINK_DIRS" "")
  if [[ -n "$dirs" ]]; then
    echo "$dirs"
    return
  fi

  local found=""
  for d in .claude; do
    if [[ -d "$root/$d" ]]; then
      found="$found $d"
    fi
  done
  echo "$found"
}

create_env_with_port() {
  local wt_dir="$1"
  local root="$2"
  local port="$3"
  local base_port="$4"

  local env_files
  env_files=$(detect_env_files "$root")

  for f in $env_files; do
    if [[ -f "$root/$f" && ! -f "$wt_dir/$f" ]]; then
      cp "$root/$f" "$wt_dir/$f"
      echo -e "  ${GREEN}✓${NC} Copied $f"
    fi
  done

  # Auto-create .env.local from .env if .env exists but .env.local doesn't
  if [[ -f "$root/.env" && ! -f "$wt_dir/.env.local" ]]; then
    cp "$root/.env" "$wt_dir/.env.local"
    echo -e "  ${GREEN}✓${NC} Created .env.local from .env"
  fi

  if [[ "$port" != "$base_port" ]]; then
    for f in $env_files; do
      if [[ -f "$wt_dir/$f" ]]; then
        if grep -q "^PORT=" "$wt_dir/$f"; then
          sed_inplace "s/^PORT=.*/PORT=$port/" "$wt_dir/$f"
        fi
        if grep -q "localhost:${base_port}" "$wt_dir/$f"; then
          sed_inplace "s/localhost:${base_port}/localhost:${port}/g" "$wt_dir/$f"
        fi
      fi
    done
    # Also update .env.local with new port
    if [[ -f "$wt_dir/.env.local" ]]; then
      if grep -q "^PORT=" "$wt_dir/.env.local"; then
        sed_inplace "s/^PORT=.*/PORT=$port/" "$wt_dir/.env.local"
      fi
      if grep -q "localhost:${base_port}" "$wt_dir/.env.local"; then
        sed_inplace "s/localhost:${base_port}/localhost:${port}/g" "$wt_dir/.env.local"
      fi
    fi
    echo -e "  ${GREEN}✓${NC} Updated port to $port in env files"
  fi
}

setup_symlinks() {
  local wt_dir="$1"
  local root="$2"

  local dirs
  dirs=$(detect_symlink_dirs "$root")

  for d in $dirs; do
    if [[ -d "$root/$d" && ! -e "$wt_dir/$d" ]]; then
      ln -s "$root/$d" "$wt_dir/$d"
      echo -e "  ${GREEN}✓${NC} Symlinked $d"
    fi
  done
}

run_install() {
  local wt_dir="$1"
  local root="$2"

  local pm
  pm=$(detect_package_manager "$root")
  local lockfile
  lockfile=$(get_lock_file "$pm")
  local install_cmd
  install_cmd=$(get_install_cmd "$pm")

  if [[ -f "$root/$lockfile" && ! -f "$wt_dir/$lockfile" ]]; then
    cp "$root/$lockfile" "$wt_dir/$lockfile"
    echo -e "  ${GREEN}✓${NC} Copied $lockfile"
  fi

  echo -e "  ${CYAN}→${NC} Running $install_cmd..."
  (cd "$wt_dir" && $install_cmd)
}

update_package_json_ports() {
  local wt_dir="$1"
  local port="$2"
  local base_port="$3"

  if [[ "$port" == "$base_port" ]]; then
    return  # No changes needed for base worktree
  fi

  local pkg="$wt_dir/package.json"

  if [[ ! -f "$pkg" ]]; then
    return
  fi

  # Update Next.js dev port: -p 3002 → -p 3005
  if grep -q "\"dev:next\".*-p ${base_port}" "$pkg"; then
    sed_inplace "s/\"dev:next\": \"next dev --turbopack -p ${base_port}\"/\"dev:next\": \"next dev --turbopack -p ${port}\"/" "$pkg"
  elif grep -q "\"dev:next\".*--port ${base_port}" "$pkg"; then
    sed_inplace "s/\"dev:next\": \"next dev --turbopack --port ${base_port}\"/\"dev:next\": \"next dev --turbopack --port ${port}\"/" "$pkg"
  fi

  # Update Inngest URLs: localhost:3002 → localhost:3005
  if grep -q "http://localhost:${base_port}/" "$pkg"; then
    sed_inplace "s|http://localhost:${base_port}/|http://localhost:${port}/|g" "$pkg"
  fi

  echo -e "  ${GREEN}✓${NC} Updated package.json ports (Next.js: $port)"
}

# ─────────────────────────────────────────────────────────────────────────────
# Terminal Integration
# ─────────────────────────────────────────────────────────────────────────────

# Navigate to worktree and optionally start Claude (stays in same terminal)
enter_worktree() {
  local path="$1"
  local auto_claude="${2:-true}"

  cd "$path" || {
    echo -e "${RED}Error: Could not cd to $path${NC}"
    return 1
  }

  if [[ "$auto_claude" == "true" ]]; then
    if command -v claude >/dev/null 2>&1; then
      exec claude
    else
      echo -e "${YELLOW}Claude CLI not found.${NC} Install from: https://claude.ai/code"
      exec "$SHELL"
    fi
  else
    exec "$SHELL"
  fi
}

# ─────────────────────────────────────────────────────────────────────────────
# GitHub Integration
# ─────────────────────────────────────────────────────────────────────────────

get_base_branch() {
  local root="$1"
  get_config_value "$root" "BASE_BRANCH" "dev"
}

get_pr_for_branch() {
  local branch="$1"
  if ! command -v gh >/dev/null 2>&1; then
    return
  fi

  local result
  result=$(gh pr list --head "$branch" --json number,state,url --jq '.[0] | "\(.number)|\(.state)|\(.url)"' 2>/dev/null || true)

  if [[ "$result" == "null|null|null" || "$result" == *"null"* ]]; then
    echo ""
  else
    echo "$result"
  fi
}

open_url() {
  local url="$1"
  if [[ "$OS" == "macos" ]]; then
    open "$url"
  elif command -v xdg-open >/dev/null 2>&1; then
    xdg-open "$url"
  elif command -v wslview >/dev/null 2>&1; then
    wslview "$url"
  else
    echo -e "${CYAN}Open:${NC} $url"
  fi
}

# ─────────────────────────────────────────────────────────────────────────────
# Commands
# ─────────────────────────────────────────────────────────────────────────────

cmd_new() {
  local branch=""
  local base_branch=""
  local skip_install=false
  local no_claude=false

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --from)
        base_branch="$2"
        shift 2
        ;;
      --no-install)
        skip_install=true
        shift
        ;;
      --no-claude)
        no_claude=true
        shift
        ;;
      *)
        branch="$1"
        shift
        ;;
    esac
  done

  if [[ -z "$branch" ]]; then
    echo -e "${RED}Usage: cw new <branch> [--from <base>] [--no-install] [--no-claude]${NC}"
    exit 1
  fi

  local root
  root=$(get_git_root)
  local wt_base
  wt_base=$(get_wt_base "$root")
  local dir_name
  dir_name=$(branch_to_dir "$branch")
  local wt_dir="${wt_base}/${dir_name}"
  local base_port
  base_port=$(detect_base_port "$root")

  echo -e "${BLUE}Creating worktree for branch:${NC} $branch"

  mkdir -p "$wt_base"

  if [[ -d "$wt_dir" ]]; then
    echo -e "${YELLOW}Worktree already exists at:${NC} $wt_dir"
    local port
    port=$(get_port_for_branch "$root" "$branch")
    if [[ -n "$port" ]]; then
      echo -e "${CYAN}Assigned port:${NC} $port"
    fi

    local auto_claude
    auto_claude=$(get_config_value "$root" "AUTO_CLAUDE" "true")
    [[ "$no_claude" == "true" ]] && auto_claude="false"

    enter_worktree "$wt_dir" "$auto_claude"
    return
  fi

  if git show-ref --verify --quiet "refs/heads/$branch" 2>/dev/null; then
    git worktree add "$wt_dir" "$branch"
  elif git show-ref --verify --quiet "refs/remotes/origin/$branch" 2>/dev/null; then
    git worktree add "$wt_dir" "$branch"
  else
    if [[ -n "$base_branch" ]]; then
      echo -e "  Creating new branch from ${CYAN}$base_branch${NC}"
      git worktree add -b "$branch" "$wt_dir" "$base_branch"
    else
      local default_base
      default_base=$(get_base_branch "$root")
      echo -e "  Creating new branch from ${CYAN}$default_base${NC}"
      git worktree add -b "$branch" "$wt_dir" "origin/$default_base" 2>/dev/null || \
        git worktree add -b "$branch" "$wt_dir"
    fi
  fi

  echo -e "${GREEN}✓${NC} Worktree created"

  local port
  port=$(find_next_port "$root" "$base_port")
  assign_port "$root" "$branch" "$port"
  echo -e "${GREEN}✓${NC} Assigned port: $port"

  echo -e "\n${BLUE}Bootstrapping environment...${NC}"
  create_env_with_port "$wt_dir" "$root" "$port" "$base_port"
  update_package_json_ports "$wt_dir" "$port" "$base_port"
  setup_symlinks "$wt_dir" "$root"

  if [[ "$skip_install" == false ]]; then
    echo ""
    run_install "$wt_dir" "$root"
  fi

  echo -e "\n${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
  echo -e "${GREEN}✓ Worktree ready!${NC}"
  echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
  echo -e "\n${CYAN}Location:${NC}  $wt_dir"
  echo -e "${CYAN}Branch:${NC}    $branch"
  echo -e "${CYAN}Port:${NC}      $port"

  local auto_claude
  auto_claude=$(get_config_value "$root" "AUTO_CLAUDE" "true")
  [[ "$no_claude" == "true" ]] && auto_claude="false"

  enter_worktree "$wt_dir" "$auto_claude"
}

cmd_go() {
  local branch="$1"
  local no_claude=false

  if [[ "$branch" == "--no-claude" ]]; then
    no_claude=true
    branch="$2"
  elif [[ "${2:-}" == "--no-claude" ]]; then
    no_claude=true
  fi

  if [[ -z "$branch" ]]; then
    echo -e "${RED}Usage: cw go <branch> [--no-claude]${NC}"
    exit 1
  fi

  local root
  root=$(get_git_root)
  local wt_base
  wt_base=$(get_wt_base "$root")
  local dir_name
  dir_name=$(branch_to_dir "$branch")
  local wt_dir="${wt_base}/${dir_name}"

  if [[ ! -d "$wt_dir" ]]; then
    echo -e "${RED}Worktree not found:${NC} $wt_dir"
    echo -e "${YELLOW}Tip:${NC} Use 'cw new $branch' to create it"
    exit 1
  fi

  local auto_claude
  auto_claude=$(get_config_value "$root" "AUTO_CLAUDE" "true")
  [[ "$no_claude" == "true" ]] && auto_claude="false"

  local port
  port=$(get_port_for_branch "$root" "$branch")

  echo -e "${CYAN}Opening worktree:${NC} $branch"
  [[ -n "$port" ]] && echo -e "${CYAN}Port:${NC} $port"

  enter_worktree "$wt_dir" "$auto_claude"
}

cmd_ls() {
  local root
  root=$(get_git_root)
  local wt_base
  wt_base=$(get_wt_base "$root")
  local base_port
  base_port=$(detect_base_port "$root")
  local repo_name
  repo_name=$(get_repo_name)

  echo -e "\n${BOLD}${BLUE}  Worktrees${NC} ${DIM}($repo_name)${NC}\n"

  git worktree list --porcelain | while read -r line; do
    if [[ "$line" == "worktree "* ]]; then
      local path="${line#worktree }"
      local branch=""
      local port=""
      local pr_info=""
      local server_status=""

      read -r line
      if [[ "$line" == "HEAD "* ]]; then
        read -r line
      fi
      if [[ "$line" == "branch "* ]]; then
        branch="${line#branch refs/heads/}"
      elif [[ "$line" == "detached" ]]; then
        branch="(detached)"
      fi

      if [[ -n "$branch" && "$branch" != "(detached)" ]]; then
        if [[ "$path" == "$root" ]]; then
          port="$base_port"
        else
          port=$(get_port_for_branch "$root" "$branch")
        fi
      fi

      if [[ -n "$port" ]] && is_port_in_use "$port"; then
        server_status="${GREEN}● running${NC}"
      else
        server_status="${DIM}○ stopped${NC}"
      fi

      if [[ -n "$branch" && "$branch" != "(detached)" ]]; then
        pr_info=$(get_pr_for_branch "$branch")
      fi

      if [[ "$path" == "$root" ]]; then
        echo -e "  ${GREEN}●${NC} ${BOLD}$branch${NC} ${DIM}(main)${NC}"
      else
        echo -e "  ${YELLOW}○${NC} ${BOLD}$branch${NC}"
      fi

      echo -e "    ${DIM}Path:${NC}   $path"
      [[ -n "$port" ]] && echo -e "    ${DIM}Port:${NC}   $port  $server_status"

      if [[ -n "$pr_info" ]]; then
        local pr_num pr_state pr_url
        pr_num=$(echo "$pr_info" | cut -d'|' -f1)
        pr_state=$(echo "$pr_info" | cut -d'|' -f2)
        pr_url=$(echo "$pr_info" | cut -d'|' -f3)

        local state_color="$YELLOW"
        [[ "$pr_state" == "MERGED" ]] && state_color="$MAGENTA"
        [[ "$pr_state" == "CLOSED" ]] && state_color="$RED"

        echo -e "    ${DIM}PR:${NC}     ${state_color}#$pr_num${NC} ($pr_state)"
      fi
      echo ""
    fi
  done
}

cmd_rm() {
  local branch="$1"

  if [[ -z "$branch" ]]; then
    echo -e "${RED}Usage: cw rm <branch>${NC}"
    exit 1
  fi

  local root
  root=$(get_git_root)
  local wt_base
  wt_base=$(get_wt_base "$root")
  local dir_name
  dir_name=$(branch_to_dir "$branch")
  local wt_dir="${wt_base}/${dir_name}"

  if [[ ! -d "$wt_dir" ]]; then
    echo -e "${RED}Worktree not found:${NC} $wt_dir"
    exit 1
  fi

  echo -e "${YELLOW}Removing worktree:${NC} $wt_dir"
  git worktree remove "$wt_dir" --force
  remove_port "$root" "$branch"
  git worktree prune
  echo -e "${GREEN}✓${NC} Worktree removed"
}

cmd_pr() {
  if ! command -v gh >/dev/null 2>&1; then
    echo -e "${RED}Error: GitHub CLI (gh) is required for PR commands${NC}"
    echo -e "${YELLOW}Install:${NC} brew install gh"
    exit 1
  fi

  local draft=false
  local title=""
  local body=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --draft|-d)
        draft=true
        shift
        ;;
      --title|-t)
        title="$2"
        shift 2
        ;;
      --body|-b)
        body="$2"
        shift 2
        ;;
      *)
        shift
        ;;
    esac
  done

  local root
  root=$(get_git_root)
  local branch
  branch=$(get_current_branch)
  local base
  base=$(get_base_branch "$root")

  if [[ -z "$branch" ]]; then
    echo -e "${RED}Error: Not on a branch${NC}"
    exit 1
  fi

  local existing_pr
  existing_pr=$(get_pr_for_branch "$branch")
  if [[ -n "$existing_pr" ]]; then
    local pr_url
    pr_url=$(echo "$existing_pr" | cut -d'|' -f3)
    echo -e "${YELLOW}PR already exists:${NC} $pr_url"
    echo -e "${CYAN}Opening in browser...${NC}"
    open_url "$pr_url"
    return
  fi

  echo -e "${BLUE}Creating PR:${NC} $branch → $base"

  if ! git ls-remote --exit-code --heads origin "$branch" >/dev/null 2>&1; then
    echo -e "${CYAN}Pushing branch to origin...${NC}"
    git push -u origin "$branch"
  fi

  local gh_cmd="gh pr create --base $base"
  [[ "$draft" == "true" ]] && gh_cmd="$gh_cmd --draft"
  [[ -n "$title" ]] && gh_cmd="$gh_cmd --title \"$title\""
  [[ -n "$body" ]] && gh_cmd="$gh_cmd --body \"$body\""
  [[ -z "$title" && -z "$body" ]] && gh_cmd="$gh_cmd --fill"

  eval "$gh_cmd"
}

cmd_prs() {
  if ! command -v gh >/dev/null 2>&1; then
    echo -e "${RED}Error: GitHub CLI (gh) is required for PR commands${NC}"
    echo -e "${YELLOW}Install:${NC} brew install gh"
    exit 1
  fi

  local root
  root=$(get_git_root)
  local repo_name
  repo_name=$(get_repo_name)

  echo -e "\n${BOLD}${BLUE}  Open PRs${NC} ${DIM}($repo_name)${NC}\n"

  gh pr list --author @me --json number,title,state,headRefName,url,reviewDecision,createdAt \
    --jq '.[] | "\(.number)|\(.title)|\(.state)|\(.headRefName)|\(.reviewDecision)|\(.url)"' 2>/dev/null | \
  while IFS='|' read -r num title state branch review url; do
    local state_icon="${YELLOW}○${NC}"
    [[ "$state" == "MERGED" ]] && state_icon="${MAGENTA}●${NC}"
    [[ "$review" == "APPROVED" ]] && state_icon="${GREEN}✓${NC}"
    [[ "$review" == "CHANGES_REQUESTED" ]] && state_icon="${RED}✗${NC}"

    echo -e "  $state_icon ${CYAN}#$num${NC} $title"
    echo -e "    ${DIM}$branch${NC}"
    echo ""
  done

  local count
  count=$(gh pr list --author @me --json number --jq 'length' 2>/dev/null || echo "0")
  echo -e "  ${DIM}$count open PR(s)${NC}\n"
}

cmd_sync() {
  local target="${1:-}"
  local root
  root=$(get_git_root)
  local branch
  branch=$(get_current_branch)

  if [[ -z "$target" ]]; then
    target=$(get_base_branch "$root")
  fi

  if [[ -z "$branch" ]]; then
    echo -e "${RED}Error: Not on a branch${NC}"
    exit 1
  fi

  echo -e "${BLUE}Syncing:${NC} $branch ← origin/$target"

  echo -e "${CYAN}Fetching origin/$target...${NC}"
  git fetch origin "$target"

  echo -e "${CYAN}Rebasing...${NC}"
  if git rebase "origin/$target"; then
    echo -e "${GREEN}✓${NC} Successfully rebased on $target"
  else
    echo -e "${RED}Rebase failed. Resolve conflicts and run:${NC}"
    echo -e "  git rebase --continue"
    echo -e "${YELLOW}Or abort with:${NC}"
    echo -e "  git rebase --abort"
    exit 1
  fi
}

cmd_status() {
  local root
  root=$(get_git_root)
  local repo_name
  repo_name=$(get_repo_name)
  local base_port
  base_port=$(detect_base_port "$root")

  echo ""
  echo -e "${BOLD}┌─────────────────────────────────────────────────────────────────┐${NC}"
  echo -e "${BOLD}│  ${BLUE}cw status${NC}${BOLD} - $repo_name$(printf '%*s' $((41 - ${#repo_name})) '')│${NC}"
  echo -e "${BOLD}├─────────────────────────────────────────────────────────────────┤${NC}"
  printf "${BOLD}│${NC}  %-22s %-6s %-14s %-16s ${BOLD}│${NC}\n" "BRANCH" "PORT" "PR" "SERVER"
  echo -e "${BOLD}├─────────────────────────────────────────────────────────────────┤${NC}"

  git worktree list --porcelain | while read -r line; do
    if [[ "$line" == "worktree "* ]]; then
      local path="${line#worktree }"
      local branch=""
      local port=""
      local pr_display="—"
      local server_display="—"

      read -r line
      if [[ "$line" == "HEAD "* ]]; then
        read -r line
      fi
      if [[ "$line" == "branch "* ]]; then
        branch="${line#branch refs/heads/}"
      fi

      [[ -z "$branch" ]] && continue

      if [[ "$path" == "$root" ]]; then
        port="$base_port"
      else
        port=$(get_port_for_branch "$root" "$branch")
      fi

      if [[ -n "$port" ]]; then
        if is_port_in_use "$port"; then
          server_display="${GREEN}✓ running${NC}"
        else
          server_display="${DIM}○ stopped${NC}"
        fi
      fi

      local pr_info
      pr_info=$(get_pr_for_branch "$branch")
      if [[ -n "$pr_info" ]]; then
        local pr_num pr_state
        pr_num=$(echo "$pr_info" | cut -d'|' -f1)
        pr_state=$(echo "$pr_info" | cut -d'|' -f2)

        case "$pr_state" in
          OPEN)   pr_display="${YELLOW}#$pr_num open${NC}" ;;
          MERGED) pr_display="${MAGENTA}#$pr_num merged${NC}" ;;
          CLOSED) pr_display="${RED}#$pr_num closed${NC}" ;;
        esac
      fi

      local branch_display="$branch"
      [[ ${#branch} -gt 20 ]] && branch_display="${branch:0:17}..."

      local icon="○"
      [[ "$path" == "$root" ]] && icon="${GREEN}●${NC}"

      printf "${BOLD}│${NC}  $icon %-20s %-6s %-14b %-16b ${BOLD}│${NC}\n" \
        "$branch_display" "${port:-—}" "$pr_display" "$server_display"
    fi
  done

  echo -e "${BOLD}└─────────────────────────────────────────────────────────────────┘${NC}"
  echo ""
}

cmd_ports() {
  local root
  root=$(get_git_root)
  local config
  config=$(get_port_config "$root")
  local base_port
  base_port=$(detect_base_port "$root")

  echo -e "\n${BOLD}${BLUE}  Port Assignments${NC}\n"
  echo -e "  ${CYAN}main${NC} → $base_port (detected)"

  if [[ -f "$config" ]]; then
    while IFS=: read -r branch port; do
      local status=""
      if is_port_in_use "$port"; then
        status=" ${GREEN}● in use${NC}"
      fi
      echo -e "  ${CYAN}$branch${NC} → $port$status"
    done < "$config"
  fi
  echo ""
}

cmd_prune() {
  local merged_only=false
  local base_branch=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --merged|-m)
        merged_only=true
        shift
        ;;
      --base|-b)
        base_branch="$2"
        shift 2
        ;;
      *)
        shift
        ;;
    esac
  done

  local root
  root=$(get_git_root)

  if [[ -z "$base_branch" ]]; then
    base_branch=$(get_base_branch "$root")
  fi

  if [[ "$merged_only" == true ]]; then
    echo -e "${BLUE}Finding worktrees for branches merged into ${CYAN}$base_branch${BLUE}...${NC}\n"

    # Get list of merged branches (excluding the base branch itself)
    local merged_branches
    merged_branches=$(git branch --merged "$base_branch" --format='%(refname:short)' 2>/dev/null | grep -v "^${base_branch}$" || true)

    if [[ -z "$merged_branches" ]]; then
      echo -e "${YELLOW}No merged branches found${NC}"
      return
    fi

    local wt_base
    wt_base=$(get_wt_base "$root")
    local config
    config=$(get_port_config "$root")
    local removed_count=0
    local freed_ports=""

    # Check each merged branch for an existing worktree
    while IFS= read -r branch; do
      [[ -z "$branch" ]] && continue

      local dir_name
      dir_name=$(branch_to_dir "$branch")
      local wt_dir="${wt_base}/${dir_name}"

      if [[ -d "$wt_dir" ]]; then
        local port
        port=$(get_port_for_branch "$root" "$branch")

        local pr_info
        pr_info=$(get_pr_for_branch "$branch")
        local pr_display="No PR"

        if [[ -n "$pr_info" ]]; then
          local pr_num pr_state
          pr_num=$(echo "$pr_info" | cut -d'|' -f1)
          pr_state=$(echo "$pr_info" | cut -d'|' -f2)

          case "$pr_state" in
            MERGED) pr_display="${MAGENTA}#$pr_num MERGED${NC}" ;;
            CLOSED) pr_display="${RED}#$pr_num CLOSED${NC}" ;;
            OPEN)   pr_display="${YELLOW}#$pr_num OPEN${NC}" ;;
          esac
        fi

        echo -e "  ${GREEN}●${NC} ${BOLD}$branch${NC}"
        echo -e "    ${DIM}Path:${NC}   $wt_dir"
        [[ -n "$port" ]] && echo -e "    ${DIM}Port:${NC}   $port"
        echo -e "    ${DIM}PR:${NC}     $pr_display"
        echo -e "    ${DIM}Status:${NC} ${GREEN}Merged into $base_branch${NC}"

        read -p "    Remove this worktree? (y/N) " -n 1 -r
        echo

        if [[ $REPLY =~ ^[Yy]$ ]]; then
          git worktree remove "$wt_dir" --force 2>/dev/null || {
            echo -e "    ${RED}✗${NC} Failed to remove (may have uncommitted changes)"
            continue
          }
          remove_port "$root" "$branch"
          echo -e "    ${GREEN}✓${NC} Removed worktree and freed port $port"

          removed_count=$((removed_count + 1))
          [[ -n "$port" ]] && freed_ports="$freed_ports $port"
        else
          echo -e "    ${DIM}Skipped${NC}"
        fi
        echo ""
      fi
    done <<< "$merged_branches"

    git worktree prune -v

    if [[ $removed_count -gt 0 ]]; then
      echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
      echo -e "${GREEN}✓ Removed $removed_count merged worktree(s)${NC}"
      [[ -n "$freed_ports" ]] && echo -e "${GREEN}✓ Freed ports:$freed_ports${NC}"
      echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    else
      echo -e "${YELLOW}No worktrees were removed${NC}"
    fi
  else
    # Original prune behavior (stale worktrees only)
    echo -e "${BLUE}Pruning stale worktrees...${NC}"
    git worktree prune -v

    local config
    config=$(get_port_config "$root")
    local wt_base
    wt_base=$(get_wt_base "$root")

    if [[ -f "$config" ]]; then
      local temp_config="${config}.tmp"
      > "$temp_config"

      while IFS=: read -r branch port; do
        local dir_name
        dir_name=$(branch_to_dir "$branch")
        if [[ -d "${wt_base}/${dir_name}" ]]; then
          echo "${branch}:${port}" >> "$temp_config"
        else
          echo -e "  ${YELLOW}Removed orphaned port:${NC} $branch → $port"
        fi
      done < "$config"

      mv "$temp_config" "$config"
    fi

    echo -e "${GREEN}✓${NC} Prune complete"
  fi
}

cmd_init() {
  local root
  root=$(get_git_root)
  local config_file="$root/.worktreerc"

  if [[ -f "$config_file" ]]; then
    echo -e "${YELLOW}Config already exists:${NC} $config_file"
    echo -e "Delete it first to regenerate."
    return
  fi

  local base_port
  base_port=$(detect_base_port "$root")
  local env_files
  env_files=$(detect_env_files "$root")
  local symlink_dirs
  symlink_dirs=$(detect_symlink_dirs "$root")

  cat > "$config_file" << EOF
# cw (Claude Worktree) configuration
# https://github.com/YOUR_USERNAME/cw

# ─────────────────────────────────────────────────────────────────
# Worktree Settings
# ─────────────────────────────────────────────────────────────────

# Base port for main worktree (worktrees get incremented ports)
BASE_PORT=$base_port

# Worktree directory (default: <repo>__wt)
# WT_BASE=~/dev/worktrees/\$(basename \$PWD)

# Env files to copy (space-separated)
ENV_FILES=$env_files

# Directories to symlink instead of copy (space-separated)
SYMLINK_DIRS=$symlink_dirs

# ─────────────────────────────────────────────────────────────────
# GitHub Settings
# ─────────────────────────────────────────────────────────────────

# Default base branch for PRs and sync
BASE_BRANCH=dev

# ─────────────────────────────────────────────────────────────────
# Terminal / Claude Settings
# ─────────────────────────────────────────────────────────────────

# Auto-start Claude Code when opening worktree
AUTO_CLAUDE=true
EOF

  echo -e "${GREEN}✓${NC} Created $config_file"
  echo -e "\n${CYAN}Detected settings:${NC}"
  echo -e "  Base port:    $base_port"
  echo -e "  Env files:    $env_files"
  echo -e "  Symlinks:     $symlink_dirs"
  echo -e "  Base branch:  dev"
  echo -e "  Auto Claude:  true"
}

cmd_version() {
  echo "cw version $VERSION"
  echo "Platform: $OS"
  echo "Terminal: $TERMINAL"
}

cmd_help() {
  cat << EOF

  ${BOLD}cw${NC} - Claude Worktree Developer Tool v$VERSION

  Manage git worktrees with Claude Code, GitHub, and terminal integration.

  ${BOLD}USAGE:${NC}
    cw <command> [arguments]

  ${BOLD}WORKTREE COMMANDS:${NC}
    new <branch> [--from <base>] [--no-install] [--no-claude]
                         Create worktree + cd into it + start Claude
    go <branch>          Switch to existing worktree + start Claude
    ls                   List all worktrees with status
    rm <branch>          Remove a worktree
    prune                Clean up stale worktrees
    prune --merged       Remove worktrees for branches merged into base

  ${BOLD}GITHUB COMMANDS:${NC}
    pr [--draft]         Create PR from current branch
    prs                  Show all your open PRs
    sync [base]          Rebase current branch on dev/main

  ${BOLD}INFO COMMANDS:${NC}
    status               Full dashboard view
    ports                Show port assignments
    init                 Create .worktreerc config
    version              Show version and platform info

  ${BOLD}EXAMPLES:${NC}
    cw new feat/auth                 # Create worktree, open with Claude
    cw new feat/x --from dev         # New branch from dev
    cw go feat/auth                  # Open existing worktree
    cw pr                            # Create PR targeting dev
    cw pr --draft                    # Create draft PR
    cw sync                          # Rebase on dev
    cw prune --merged                # Remove merged branch worktrees
    cw status                        # See everything

  ${BOLD}CONFIG (.worktreerc):${NC}
    Run 'cw init' to create config with detected settings.
    Customize BASE_PORT, BASE_BRANCH, AUTO_CLAUDE, etc.

  ${BOLD}MORE INFO:${NC}
    https://github.com/YOUR_USERNAME/cw

EOF
}

# ─────────────────────────────────────────────────────────────────────────────
# Main
# ─────────────────────────────────────────────────────────────────────────────

main() {
  local cmd="${1:-help}"
  shift || true

  case "$cmd" in
    new)     cmd_new "$@" ;;
    go)      cmd_go "$@" ;;
    ls)      cmd_ls ;;
    rm)      cmd_rm "$@" ;;
    pr)      cmd_pr "$@" ;;
    prs)     cmd_prs ;;
    sync)    cmd_sync "$@" ;;
    status)  cmd_status ;;
    ports)   cmd_ports ;;
    prune)   cmd_prune ;;
    init)    cmd_init ;;
    version|--version|-v) cmd_version ;;
    help|--help|-h)       cmd_help ;;
    *)
      echo -e "${RED}Unknown command:${NC} $cmd"
      cmd_help
      exit 1
      ;;
  esac
}

main "$@"
